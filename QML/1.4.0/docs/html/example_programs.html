

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Example Programs &mdash; Qualcomm Math Library</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Qualcomm Math Library" href="index.html"/>
        <link rel="up" title="Using QML" href="using_qml.html"/>
        <link rel="next" title="QML API Reference" href="blas_index.html"/>
        <link rel="prev" title="QML" href="qml_types.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> QML
          

          
          </a>

          
            
            
              <div class="version">
                1.4.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction to BLAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction_lapack.html">Introduction to LAPACK</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="using_qml.html">Using QML</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="qml_types.html">QML</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Example Programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#minimal-example">Minimal Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cblas-example">CBLAS Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blas-solve-example">BLAS Solve Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lapack-least-squares-example">LAPACK Least Squares Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lapack-singular-value-decomposition">LAPACK Singular Value Decomposition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-the-examples">Building the Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-the-examples">Running the Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#platform-control">Platform control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-install">Local install</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="blas_index.html">QML API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">QML</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="using_qml.html">Using QML</a> &raquo;</li>
      
    <li>Example Programs</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="example-programs">
<h1>Example Programs<a class="headerlink" href="#example-programs" title="Permalink to this headline">¶</a></h1>
<p>All the example code can be found in the <code class="docutils literal"><span class="pre">examples/</span></code> subdirectory at
the installation prefix location.</p>
<div class="section" id="minimal-example">
<h2>Minimal Example<a class="headerlink" href="#minimal-example" title="Permalink to this headline">¶</a></h2>
<p>This example shows the minimal code needed to call a QML function.</p>
<p>This example constructs matrices <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> that are both 1024x1024
filled with unit values. It then calls <code class="docutils literal"><span class="pre">sgemm</span></code> to multiply the matrices
and store the 1024x1024 result in matrix <code class="docutils literal"><span class="pre">C</span></code>. The first value in the resulting
matrix is displayed, which should be 1024.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;qml.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">matrixSize</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
    
    <span class="kt">float</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">matrixSize</span><span class="p">];</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">B</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">matrixSize</span><span class="p">];</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">matrixSize</span><span class="p">];</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrixSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">cblas_sgemm</span><span class="p">(</span><span class="n">CblasRowMajor</span><span class="p">,</span> <span class="n">CblasNoTrans</span><span class="p">,</span> <span class="n">CblasNoTrans</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span>
        <span class="mf">1.0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Value of C[0] is: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">C</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">B</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">A</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cblas-example">
<h2>CBLAS Example<a class="headerlink" href="#cblas-example" title="Permalink to this headline">¶</a></h2>
<p>This example shows how row-major indexing works in CBLAS
and how offsets and leading dimensions can be passed to QML
functions to operate on subregions of larger matrices.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;qml.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cm">/* Example program that uses the CBLAS interface to permute part of a matrix.</span>
<span class="cm">   </span>
<span class="cm">   This program constructs a matrix A of size 6x8 with entries:</span>
<span class="cm">   </span>
<span class="cm">   [  1,  2,  3,  4,  5,  6,  7,  8; ]</span>
<span class="cm">   [  9, 10, 11, 12, 13, 14, 15, 16; ]</span>
<span class="cm">   [ 17, 18, 19, 20, 21, 22, 23, 24; ]</span>
<span class="cm">   [ 25, 26, 27, 28, 29, 30, 31, 32; ]</span>
<span class="cm">   [ 33, 34, 35, 36, 37, 38, 39, 40; ]</span>
<span class="cm">   [ 41, 42, 43, 44, 45, 46, 47, 48; ]</span>
<span class="cm">   </span>
<span class="cm">   It constructs an explicit permutation matrix of size 4x4 with entries:</span>

<span class="cm">   [ 0, 1, 0, 0; ]</span>
<span class="cm">   [ 1, 0, 0, 0; ]</span>
<span class="cm">   [ 0, 0, 0, 1; ]</span>
<span class="cm">   [ 0, 0, 1, 0; ]</span>
<span class="cm">   </span>
<span class="cm">   The operation to be performed is to apply the permutation matrix</span>
<span class="cm">   to the lower left quadrant of A on the right and store the result in</span>
<span class="cm">   a new matrix C. The result matrix C should be:</span>

<span class="cm">   [ 17, 18, 19, 20; ]   [ 0, 1, 0, 0; ]   [ 18, 17, 20, 19; ]</span>
<span class="cm">   [ 25, 26, 27, 28; ] * [ 1, 0, 0, 0; ] = [ 26, 25, 28, 27; ]</span>
<span class="cm">   [ 33, 34, 35, 36; ]   [ 0, 0, 0, 1; ]   [ 34, 33, 36, 35; ]</span>
<span class="cm">   [ 41, 42, 43, 44; ]   [ 0, 0, 1, 0; ]   [ 42, 41, 44, 43; ]</span>

<span class="cm">   All matrices are stored in row-major order in double precision.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A is 6 x 8</span>
    <span class="c1">// Create on the heap</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">A_rows</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">A_cols</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">A_rows</span> <span class="o">*</span> <span class="n">A_cols</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LDA</span> <span class="o">=</span> <span class="n">A_cols</span><span class="p">;</span>

    <span class="c1">// Fill out A</span>
    <span class="c1">// Row-major means adjacent memory locations are increasing</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A_rows</span> <span class="o">*</span> <span class="n">A_cols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// P is k x k</span>
    <span class="c1">// Create on the stack</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">P_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">P</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LDP</span> <span class="o">=</span> <span class="n">P_size</span><span class="p">;</span>

    <span class="c1">// C is k x k</span>
    <span class="c1">// Create on the heap</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">P_size</span> <span class="o">*</span> <span class="n">P_size</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LDC</span> <span class="o">=</span> <span class="n">P_size</span><span class="p">;</span>

    <span class="c1">// CBLAS call to dgemm</span>
    <span class="c1">// Operation:</span>
    <span class="c1">//     C := 1.0 * P * A[3..6][1..4] + 0.0 * C</span>
    <span class="n">cblas_dgemm</span><span class="p">(</span><span class="n">CblasRowMajor</span><span class="p">,</span> <span class="n">CblasNoTrans</span><span class="p">,</span> <span class="n">CblasNoTrans</span><span class="p">,</span> <span class="n">P_size</span><span class="p">,</span> <span class="n">P_size</span><span class="p">,</span>
        <span class="n">P_size</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">A</span> <span class="o">+</span> <span class="n">LDA</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">LDA</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">LDP</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">LDC</span><span class="p">);</span>

    <span class="c1">// Show result matrix C in row-major order</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">P_size</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">P_size</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">C</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">LDC</span> <span class="o">*</span> <span class="n">row</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Cleanup</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">C</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="blas-solve-example">
<h2>BLAS Solve Example<a class="headerlink" href="#blas-solve-example" title="Permalink to this headline">¶</a></h2>
<p>This example shows how to use the Fortran BLAS interface
from C++ code to solve a system of linear equations.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;qml.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cm">/* Example program that uses the BLAS interface to solve a system of</span>
<span class="cm">   equations.</span>
<span class="cm">   </span>
<span class="cm">   This program constructs a matrix A of size 7x7 with entries:</span>
<span class="cm">   </span>
<span class="cm">   [ 1,  0,   0,     0,  0 ]</span>
<span class="cm">   [ 0,  2,  -1,     0,  0 ]</span>
<span class="cm">   [ 0,  0, 1.5,    -1,  0 ]</span>
<span class="cm">   [ 0,  0,   0, 1.333, -1 ]</span>
<span class="cm">   [ 0,  0,   0,     0,  1 ]</span>
<span class="cm">   </span>
<span class="cm">   and a vector b with entries:</span>

<span class="cm">   [     1 ]</span>
<span class="cm">   [     2 ]</span>
<span class="cm">   [     2 ]</span>
<span class="cm">   [ 2.333 ]</span>
<span class="cm">   [     1 ]</span>

<span class="cm">   We would like to solve the system of equations A * x = b for x.</span>
<span class="cm">   </span>
<span class="cm">   Matrix A is stored in column-major order using single precision.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A is 5x5</span>
    <span class="c1">// Create on the heap</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">A_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">A_size</span> <span class="o">*</span> <span class="n">A_size</span><span class="p">]{};</span> <span class="c1">// Initialize to 0</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">LDA</span> <span class="o">=</span> <span class="n">A_size</span><span class="p">;</span>

    <span class="c1">// Fill out non-zero A entries</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.33333333f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">LDA</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>

    <span class="c1">// b is length 7</span>
    <span class="c1">// Create on the stack, name V since it will also hold x</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">V_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">V</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="mf">2.33333333f</span><span class="p">,</span> <span class="mf">1.0f</span> <span class="p">};</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">INCV</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// BLAS call to strsv (single precision triangular solver)</span>
    <span class="c1">// Operation:</span>
    <span class="c1">//     Solve A x = b for x</span>
    <span class="c1">//     Upper triangular</span>
    <span class="c1">//     Non-transposed solve</span>
    <span class="c1">//     Non-unit diagonal</span>
    <span class="c1">// Note we pass addresses of scalars following Fortran convention</span>
    <span class="n">strsv</span><span class="p">(</span><span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="s">&quot;N&quot;</span><span class="p">,</span> <span class="s">&quot;N&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A_size</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LDA</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">INCV</span><span class="p">);</span>

    <span class="c1">// Show result vector</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">qml_long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">V_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Cleanup</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="lapack-least-squares-example">
<h2>LAPACK Least Squares Example<a class="headerlink" href="#lapack-least-squares-example" title="Permalink to this headline">¶</a></h2>
<p>This example shows how to use the LAPACK interface of QML from C++
code to find the best-fit quadratic equation through a set of points.
The example calls <code class="docutils literal"><span class="pre">dgels</span></code> to compute the linear least squares solution.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;qml.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cm">/* Example program that uses the LAPACK interface to compute</span>
<span class="cm">   the best-fit quadratic equation through a set of data points.</span>

<span class="cm">   The problem is to find values for beta_0, beta_1, and beta_2 so that</span>
<span class="cm">   the formula</span>
<span class="cm">   </span>
<span class="cm">   y = beta_0 + beta_1 * x + beta_2 * x^2</span>
<span class="cm">   </span>
<span class="cm">   is the &quot;best&quot; approximation to the following observed data points.</span>

<span class="cm">    x   | y</span>
<span class="cm">   -----+-----</span>
<span class="cm">    1   | 3</span>
<span class="cm">    2   | 4</span>
<span class="cm">    4   | 13</span>
<span class="cm">    5   | 27</span>

<span class="cm">   Here &quot;best&quot; means minimizing the sum of the squares of the</span>
<span class="cm">   differences.</span>
<span class="cm">   </span>
<span class="cm">   We use the LAPACK GELS function to compute a least-squares solution</span>
<span class="cm">   to the overdetermined A * x = b.</span>

<span class="cm">   A is the matrix:</span>

<span class="cm">   [ 1    1    1  ]</span>
<span class="cm">   [ 1    2    4  ]</span>
<span class="cm">   [ 1    4    16 ]</span>
<span class="cm">   [ 1    5    25 ]</span>

<span class="cm">   x is the unknown vector:</span>
<span class="cm">   </span>
<span class="cm">   [ beta_0 ]</span>
<span class="cm">   [ beta_1 ]</span>
<span class="cm">   [ beta_2 ]</span>
<span class="cm">   </span>
<span class="cm">   b is the matrix:</span>
<span class="cm">   </span>
<span class="cm">   [  3 ]</span>
<span class="cm">   [  4 ]</span>
<span class="cm">   [ 13 ]</span>
<span class="cm">   [ 27 ]</span>

<span class="cm">   Matrix A is stored in column-major order in double precision.</span>
<span class="cm">   Even though x and b are vectors here, GELS can handle multiple right</span>
<span class="cm">   hand sides simultaneously so it takes x and b as matrices.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A is 4x3</span>
    <span class="c1">// Create on the heap</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">A_rows</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">A_cols</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// Column major, each text row below is a column of A</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">A_rows</span> <span class="o">*</span> <span class="n">A_cols</span><span class="p">]{</span>
        <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span>
        <span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">25.0</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">LDA</span> <span class="o">=</span> <span class="n">A_rows</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">NRHS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// b is length 4</span>
    <span class="c1">// Will contain x after dgels returns</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">B_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">X_size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">B</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">B_size</span><span class="p">]{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">,</span> <span class="mf">27.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">LDB</span> <span class="o">=</span> <span class="n">B_size</span><span class="p">;</span>

    <span class="c1">// Query required workspace size</span>
    <span class="n">qml_long</span> <span class="n">lwork</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// query into first position of workspace</span>
    <span class="kt">double</span> <span class="n">opt_worksize</span><span class="p">;</span>
    <span class="n">qml_long</span> <span class="n">info</span><span class="p">;</span>
    <span class="n">dgels</span><span class="p">(</span><span class="s">&quot;N&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A_rows</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A_cols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NRHS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LDA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LDB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt_worksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lwork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// Allocate optimal scratch space</span>
    <span class="c1">// (Need cast to integer type because optimal size is given as a double)</span>
    <span class="n">lwork</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">qml_long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">opt_worksize</span><span class="p">);</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">WORK</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">lwork</span><span class="p">]{};</span>

    <span class="c1">// LAPACK call to dgels (double precision least squares solver)</span>
    <span class="n">dgels</span><span class="p">(</span><span class="s">&quot;N&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A_rows</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A_cols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NRHS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LDA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">LDB</span><span class="p">,</span> <span class="n">WORK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lwork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// Check for success</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ERROR computing least squares solution&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Show result (should be y = 8.73333 * x^0  + -7.3 * x^1  + 2.16667 * x^2)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Best fit equation is y = &quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">qml_long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">X_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; * x^&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">X_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; + &quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Cleanup</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">B</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">WORK</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="lapack-singular-value-decomposition">
<h2>LAPACK Singular Value Decomposition<a class="headerlink" href="#lapack-singular-value-decomposition" title="Permalink to this headline">¶</a></h2>
<p>This example shows how to use the LAPACK interface of QML from C++
code to find the singular value decomposition of a matrix. It calls
<code class="docutils literal"><span class="pre">dgesvd</span></code> to do the decomposition.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;qml.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cm">/* Example program that uses the LAPACK interface to compute</span>
<span class="cm">   the singular value decomposition (SVD) of a matrix.</span>

<span class="cm">   The problem is to find U, SIGMA, and V^T such that</span>
<span class="cm">   </span>
<span class="cm">   U * SIGMA * V^T = [ 3  2  2 ]</span>
<span class="cm">                     [ 2  3 -2 ]</span>
<span class="cm">    </span>
<span class="cm">   where U is a 2x2 orthogonal matrix, V^T is a 3x3 orthogonal matrix,</span>
<span class="cm">   and SIGMA is a 2x3 matrix with non-zero elements only on the diagonal.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A is 2x3</span>
    <span class="c1">// Create on the heap</span>
    <span class="k">const</span> <span class="n">qml_long</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// Column major, each text row below is a column of A</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">A</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">]{</span>
        <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span>
    <span class="p">};</span>

    <span class="c1">// S is diagonal entries of SIGMA</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">S</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">rows</span><span class="p">]{};</span>

    <span class="c1">// U is 2x2</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">U</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">rows</span> <span class="o">*</span> <span class="n">rows</span><span class="p">]{};</span>

    <span class="c1">// VT is 3x3</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">VT</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">cols</span> <span class="o">*</span> <span class="n">cols</span><span class="p">]{};</span>

    <span class="c1">// Query required workspace size</span>
    <span class="n">qml_long</span> <span class="n">lwork</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// query into first position of workspace</span>
    <span class="kt">double</span> <span class="n">opt_worksize</span><span class="p">;</span>
    <span class="n">qml_long</span> <span class="n">info</span><span class="p">;</span>
    <span class="n">dgesvd</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cols</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cols</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt_worksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lwork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// Allocate optimal scratch space</span>
    <span class="c1">// (Need cast to integer type because optimal size is given as a double)</span>
    <span class="n">lwork</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">qml_long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">opt_worksize</span><span class="p">);</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">WORK</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">lwork</span><span class="p">]{};</span>

    <span class="c1">// Do SVD</span>
    <span class="n">dgesvd</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cols</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rows</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cols</span><span class="p">,</span> <span class="n">WORK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lwork</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// Check for success</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ERROR computing SVD&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Show singular values (should be [ 5 3 ])</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Singular values are [ &quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">qml_long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// Show the first left singular vector (should be [ -0.707107 -0.707107 ])</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;First left singular vector is [ &quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">qml_long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="c1">// Cleanup</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">S</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">U</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">VT</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">WORK</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="building-the-examples">
<h2>Building the Examples<a class="headerlink" href="#building-the-examples" title="Permalink to this headline">¶</a></h2>
<p>One way to build your application or library and link against QML
is to use the official Android NDK. You declare that QML is a
pre-built library using directives in an <code class="docutils literal"><span class="pre">Android.mk</span></code> file inside the
<code class="docutils literal"><span class="pre">jni</span></code> directory of an application tree.</p>
<div class="highlight-make"><div class="highlight"><pre><span class="cp">include $(CLEAR_VARS)</span>
<span class="nv">LOCAL_MODULE</span> <span class="o">:=</span> QML
<span class="nv">LOCAL_SRC_FILES</span> <span class="o">:=</span> &lt;install-prefix&gt;/lib&lt;name&gt;.so
<span class="nv">LOCAL_EXPORT_C_INCLUDES</span> <span class="o">:=</span> &lt;install-prefix&gt;/include
<span class="cp">include $(PREBUILT_SHARED_LIBRARY)</span>
</pre></div>
</div>
<p>Once this module has been declared, you can let the build system
know that your application links against QML by adding the following
directive to your application&#8217;s <code class="docutils literal"><span class="pre">Android.mk</span></code>:</p>
<div class="highlight-make"><div class="highlight"><pre><span class="nv">LOCAL_SHARED_LIBRARIES</span> <span class="o">+=</span> QML
</pre></div>
</div>
<p>To have access to newer C++11 features you also need to link against a
full-featured version of the C++ runtime library and enable C++11
features in the compiler. These settings are set in <code class="docutils literal"><span class="pre">Application.mk</span></code>.</p>
<div class="highlight-make"><div class="highlight"><pre><span class="nv">APP_STL</span> <span class="o">:=</span> gnustl_shared
<span class="nv">APP_CPPFLAGS</span> <span class="o">+=</span> -std<span class="o">=</span>c++11
</pre></div>
</div>
<p>To build the provided example programs in this way, run <code class="docutils literal"><span class="pre">ndk-build</span></code>
from the <code class="docutils literal"><span class="pre">examples/</span></code> directory of the installation within the desired
architecture. This will produce executables and library files inside
<code class="docutils literal"><span class="pre">libs/&lt;arch&gt;/</span></code>. Within the context of a complete application, these
executables and libraries will be included as part of the final APK
and installed in the correct location on application install.</p>
</div>
<div class="section" id="running-the-examples">
<h2>Running the Examples<a class="headerlink" href="#running-the-examples" title="Permalink to this headline">¶</a></h2>
<p>There are two main ways to run the examples. If you control the Android
platform on the device, you can add QML to the system
libraries that are available to all applications. If you do not
control the platform then you will include the libraries as part of
your application so they will be installed in the private application
area during installation.</p>
<div class="section" id="platform-control">
<h3>Platform control<a class="headerlink" href="#platform-control" title="Permalink to this headline">¶</a></h3>
<p>If you control the Android platform, you can install the QML
into the system libraries location of the device. The typical
location would be <code class="docutils literal"><span class="pre">/system/vendor/lib/</span></code> for 32-bit architectures
or <code class="docutils literal"><span class="pre">/system/vendor/lib64/</span></code> for 64-bit architectures.
With root access in ADB this can be done for testing purposes using <code class="docutils literal"><span class="pre">adb</span> <span class="pre">push</span></code>.</p>
<p>Once the libraries are installed in system locations, running the examples
requires copying the executables to any location on the device and running
them.</p>
</div>
<div class="section" id="local-install">
<h3>Local install<a class="headerlink" href="#local-install" title="Permalink to this headline">¶</a></h3>
<p>To run the executables without root access, copy the libraries and executables from
<code class="docutils literal"><span class="pre">libs/&lt;arch&gt;/</span></code> to an accessible directory on the device such as <code class="docutils literal"><span class="pre">/data/local/test</span></code>. Once QML,
and the test application are all in the same directory, run the executable with a command such as:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>. ./MinimalExample
</pre></div>
</div>
<p>Complete applications packaged inside an APK will automatically install
the libraries into the correct locations during installation if the libraries
are declared as previously described in the <code class="docutils literal"><span class="pre">Android.mk</span></code> file.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="blas_index.html" class="btn btn-neutral float-right" title="QML API Reference" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="qml_types.html" class="btn btn-neutral" title="QML" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Qualcomm Technologies, Inc.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>